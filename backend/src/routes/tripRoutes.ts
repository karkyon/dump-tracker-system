// =====================================
// backend/src/routes/tripRoutes.ts
// ÈÅãË°åÁÆ°ÁêÜ„É´„Éº„ÉàÁµ±Âêà - ÂÆåÂÖ®„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Êîπ‰øÆÁâà
// ÈÅãË°åË®òÈå≤CRUD„ÉªGPSÈÄ£Êê∫„ÉªÁä∂ÊÖãÁÆ°ÁêÜ„Éª„É™„Ç¢„É´„Çø„Ç§„É†ËøΩË∑°„ÉªÁµ±Ë®àÂàÜÊûê
// ÊúÄÁµÇÊõ¥Êñ∞: 2025Âπ¥9Êúà28Êó•
// ‰æùÂ≠òÈñ¢‰øÇ: middleware/auth.ts, models/OperationModel.ts, utils/gpsCalculations.ts
// =====================================

import { Router, Request, Response } from 'express';

// üéØ Phase 1ÂÆå‰∫ÜÂü∫Áõ§„ÅÆÊ¥ªÁî®
import { authenticateToken, authorize } from '../middleware/auth';
import { asyncHandler } from '../middleware/errorHandler';
import logger from '../utils/logger';

// üéØ Áµ±ÂêàÂü∫Áõ§Ê¥ªÁî®
import { 
  AppError, 
  ValidationError, 
  AuthorizationError,
  NotFoundError,
  DatabaseError,
  ConflictError 
} from '../utils/errors';

import { 
  sendSuccess, 
  sendError, 
  sendValidationError 
} from '../utils/response';

import { DATABASE_SERVICE } from '../utils/database';

// üéØ GPSË®àÁÆó„Éª‰ΩçÁΩÆÁÆ°ÁêÜÁµ±Âêà
import {
  calculateDistance,
  isValidCoordinates,
  calculateRoute,
  calculateFuelEfficiency
} from '../utils/gpsCalculations';

// üéØ ÂûãÂÆöÁæ©Áµ±ÂêàÔºàOperationModel.tsÊ¥ªÁî®Ôºâ
import type {
  TripOperationModel,
  OperationStatistics,
  OperationTripFilter,
  StartTripOperationRequest,
  EndTripOperationRequest,
  UpdateTripOperationRequest
} from '../models/OperationModel';

import type {
  TripListResponse,
  TripDetailResponse,
  TripStatsResponse,
  CreateTripRequest,
  UpdateTripRequest
} from '../types/trip';

import type {
  PaginationQuery,
  ApiResponse,
  ApiListResponse
} from '../types/common';

import type { 
  OperationStatus, 
  OperationType,
  UserRole,
  Prisma 
} from '@prisma/client';

const router = Router();

// ÂÖ®„Å¶„ÅÆÈÅãË°åÁÆ°ÁêÜ„É´„Éº„Éà„ÅßË™çË®º„ÅåÂøÖË¶Å
router.use(authenticateToken);

// =====================================
// ÈÅãË°åÁÆ°ÁêÜAPIÂÆüË£ÖÔºàÁµ±ÂêàÂü∫Áõ§Ê¥ªÁî®ÁâàÔºâ
// =====================================

/**
 * ÈÅãË°åË®òÈå≤‰∏ÄË¶ßÂèñÂæó
 * „Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥„ÉªÊ§úÁ¥¢„Éª„Éï„Ç£„É´„Çø„ÉªGPSÊÉÖÂ†±„ÉªÁµ±Ë®àÊÉÖÂ†±ÂØæÂøú
 * 
 * @route GET /trips
 * @param {OperationTripFilter} query - „Éï„Ç£„É´„Çø„Éª„Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥ÊÉÖÂ†±
 * @returns {TripListResponse} ÈÅãË°åË®òÈå≤‰∏ÄË¶ß„Å®„Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥ÊÉÖÂ†±
 */
router.get('/', asyncHandler(async (req: Request, res: Response) => {
  try {
    const {
      page = 1,
      limit = 10,
      vehicleId,
      driverId,
      tripStatus,
      startDate,
      endDate,
      minDistance,
      maxDistance,
      priority,
      hasGpsData,
      includeStatistics = false,
      sortBy = 'createdAt',
      sortOrder = 'desc'
    } = req.query;

    // „Éë„É©„É°„Éº„Çø„Éê„É™„Éá„Éº„Ç∑„Éß„É≥
    const pageNum = Math.max(1, parseInt(page as string) || 1);
    const limitNum = Math.min(100, Math.max(1, parseInt(limit as string) || 10));
    const offset = (pageNum - 1) * limitNum;

    const prisma = DATABASE_SERVICE.getInstance();

    // Ê§úÁ¥¢„Éª„Éï„Ç£„É´„ÇøÊù°‰ª∂ÊßãÁØâ
    const whereConditions: Prisma.OperationWhereInput = {
      operationType: 'TRIP'
    };

    // Ëªä‰∏°„Éï„Ç£„É´„Çø
    if (vehicleId) {
      whereConditions.vehicleId = parseInt(vehicleId as string);
    }

    // ÈÅãËª¢Êâã„Éï„Ç£„É´„ÇøÔºàË™çË®ºÊ∏à„Åø„É¶„Éº„Ç∂„ÉºËá™Ë∫´„Åæ„Åü„ÅØÁÆ°ÁêÜËÄÖ„Éª„Éû„Éç„Éº„Ç∏„É£„Éº„ÅÆÂ†¥ÂêàÔºâ
    if (driverId) {
      const canAccessOthers = ['ADMIN', 'MANAGER'].includes(req.user?.role || '');
      if (parseInt(driverId as string) !== req.user?.userId && !canAccessOthers) {
        throw new AuthorizationError('‰ªñ„ÅÆÈÅãËª¢Êâã„ÅÆÈÅãË°åË®òÈå≤„Å´„Ç¢„ÇØ„Çª„Çπ„Åô„ÇãÊ®©Èôê„Åå„ÅÇ„Çä„Åæ„Åõ„Çì', 'ACCESS_DENIED');
      }
      whereConditions.driverId = parseInt(driverId as string);
    } else if (req.user?.role === 'DRIVER') {
      // „Éâ„É©„Ç§„Éê„Éº„ÅØËá™ÂàÜ„ÅÆÈÅãË°åË®òÈå≤„ÅÆ„ÅøË°®Á§∫
      whereConditions.driverId = req.user.userId;
    }

    // Áä∂ÊÖã„Éï„Ç£„É´„Çø
    if (tripStatus) {
      const statusArray = Array.isArray(tripStatus) ? tripStatus : [tripStatus];
      whereConditions.status = { in: statusArray as OperationStatus[] };
    }

    // ÊúüÈñì„Éï„Ç£„É´„Çø
    if (startDate || endDate) {
      whereConditions.createdAt = {};
      if (startDate) {
        whereConditions.createdAt.gte = new Date(startDate as string);
      }
      if (endDate) {
        whereConditions.createdAt.lte = new Date(endDate as string);
      }
    }

    // Ë∑ùÈõ¢„Éï„Ç£„É´„ÇøÔºà„É°„Çø„Éá„Éº„Çø„Åã„ÇâÔºâ
    if (minDistance || maxDistance) {
      const distanceFilter: any = {};
      if (minDistance) distanceFilter.gte = parseFloat(minDistance as string);
      if (maxDistance) distanceFilter.lte = parseFloat(maxDistance as string);
      whereConditions.metadata = {
        path: ['actualDistance'],
        ...distanceFilter
      };
    }

    // ÂÑ™ÂÖàÂ∫¶„Éï„Ç£„É´„Çø
    if (priority) {
      const priorityArray = Array.isArray(priority) ? priority : [priority];
      whereConditions.priority = { in: priorityArray };
    }

    // GPS„Éá„Éº„ÇøÊúâÁÑ°„Éï„Ç£„É´„Çø
    if (hasGpsData === 'true') {
      whereConditions.gpsLogs = {
        some: {}
      };
    }

    // „ÇΩ„Éº„ÉàÊù°‰ª∂ÊßãÁØâ
    const validSortFields = ['createdAt', 'startTime', 'endTime', 'status'];
    const sortField = validSortFields.includes(sortBy as string) ? sortBy as string : 'createdAt';
    const orderByClause = { [sortField]: sortOrder === 'asc' ? 'asc' : 'desc' };

    // „Éá„Éº„ÇøÂèñÂæó
    const [operations, totalCount] = await Promise.all([
      prisma.operation.findMany({
        where: whereConditions,
        orderBy: orderByClause,
        skip: offset,
        take: limitNum,
        include: {
          vehicle: {
            select: {
              id: true,
              plateNumber: true,
              model: true,
              type: true
            }
          },
          driver: {
            select: {
              id: true,
              username: true,
              email: true
            }
          },
          gpsLogs: hasGpsData === 'true' ? {
            take: 10,
            orderBy: { timestamp: 'desc' },
            select: {
              id: true,
              latitude: true,
              longitude: true,
              timestamp: true
            }
          } : false
        }
      }),
      prisma.operation.count({ where: whereConditions })
    ]);

    const totalPages = Math.ceil(totalCount / limitNum);

    // Áµ±Ë®àÊÉÖÂ†±ÂèñÂæóÔºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ
    let statistics: OperationStatistics | undefined;
    if (includeStatistics === 'true') {
      statistics = await generateTripStatistics(prisma, whereConditions);
    }

    logger.info('ÈÅãË°åË®òÈå≤‰∏ÄË¶ßÂèñÂæó', {
      requestBy: req.user?.username,
      requestRole: req.user?.role,
      totalCount,
      page: pageNum,
      filters: { vehicleId, driverId, tripStatus, startDate, endDate }
    });

    const response: TripListResponse = {
      trips: operations.map(operation => ({
        id: operation.id,
        vehicleId: operation.vehicleId,
        driverId: operation.driverId,
        status: operation.status,
        startTime: operation.startTime,
        endTime: operation.endTime,
        actualDistance: operation.metadata?.actualDistance || 0,
        duration: operation.duration,
        priority: operation.priority,
        vehicle: operation.vehicle,
        driver: operation.driver,
        recentGpsData: operation.gpsLogs || []
      })),
      pagination: {
        page: pageNum,
        limit: limitNum,
        total: totalCount,
        totalPages,
        hasNext: pageNum < totalPages,
        hasPrev: pageNum > 1
      },
      statistics,
      filters: {
        vehicleId: vehicleId as string,
        driverId: driverId as string,
        tripStatus: tripStatus as string[],
        startDate: startDate as string,
        endDate: endDate as string
      }
    };

    return sendSuccess(res, response, 'ÈÅãË°åË®òÈå≤‰∏ÄË¶ß„ÇíÂèñÂæó„Åó„Åæ„Åó„Åü');

  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }

    logger.error('ÈÅãË°åË®òÈå≤‰∏ÄË¶ßÂèñÂæó„Ç®„É©„Éº', {
      requestBy: req.user?.username,
      error: error instanceof Error ? error.message : String(error)
    });

    throw new DatabaseError('ÈÅãË°åË®òÈå≤‰∏ÄË¶ß„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'TRIP_LIST_ERROR');
  }
}));

/**
 * ÈÅãË°åË®òÈå≤Ë©≥Á¥∞ÂèñÂæó
 * GPSÂ±•Ê≠¥„Éª„É´„Éº„ÉàÊÉÖÂ†±„ÉªÂäπÁéáÂàÜÊûêÊÉÖÂ†±„ÇíÂê´„ÇÄË©≥Á¥∞ÊÉÖÂ†±ÂèñÂæó
 * 
 * @route GET /trips/:id
 * @param {string} id - ÈÅãË°åË®òÈå≤ID
 * @returns {TripDetailResponse} ÈÅãË°åË®òÈå≤Ë©≥Á¥∞ÊÉÖÂ†±
 * @throws {NotFoundError} ÈÅãË°åË®òÈå≤„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà
 * @throws {AuthorizationError} Ê®©Èôê„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà
 */
router.get('/:id', asyncHandler(async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const requestUserId = req.user?.userId;
    const requestUserRole = req.user?.role;

    // ID„Éê„É™„Éá„Éº„Ç∑„Éß„É≥
    const operationId = parseInt(id);
    if (isNaN(operationId)) {
      throw new ValidationError('ÁÑ°Âäπ„Å™ÈÅãË°åË®òÈå≤ID„Åß„Åô', 'INVALID_OPERATION_ID');
    }

    const prisma = DATABASE_SERVICE.getInstance();

    const operation = await prisma.operation.findUnique({
      where: { 
        id: operationId,
        operationType: 'TRIP'
      },
      include: {
        vehicle: {
          select: {
            id: true,
            plateNumber: true,
            model: true,
            type: true,
            fuelType: true,
            capacity: true
          }
        },
        driver: {
          select: {
            id: true,
            username: true,
            email: true,
            role: true
          }
        },
        gpsLogs: {
          orderBy: { timestamp: 'asc' },
          select: {
            id: true,
            latitude: true,
            longitude: true,
            speed: true,
            altitude: true,
            accuracy: true,
            timestamp: true
          }
        }
      }
    });

    if (!operation) {
      throw new NotFoundError('ÈÅãË°åË®òÈå≤„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', 'OPERATION_NOT_FOUND');
    }

    // Ê®©Èôê„ÉÅ„Çß„ÉÉ„ÇØÔºàËá™ÂàÜ„ÅÆÈÅãË°å„Åæ„Åü„ÅØÁÆ°ÁêÜËÄÖ„Éª„Éû„Éç„Éº„Ç∏„É£„ÉºÔºâ
    const canAccessOthers = ['ADMIN', 'MANAGER'].includes(requestUserRole || '');
    if (operation.driverId !== requestUserId && !canAccessOthers) {
      throw new AuthorizationError('„Åì„ÅÆÈÅãË°åË®òÈå≤„Å´„Ç¢„ÇØ„Çª„Çπ„Åô„ÇãÊ®©Èôê„Åå„ÅÇ„Çä„Åæ„Åõ„Çì', 'ACCESS_DENIED');
    }

    // ÈÅãË°åÂäπÁéáÂàÜÊûêË®àÁÆó
    const efficiency = await calculateTripEfficiency(operation);

    // GPSÂ±•Ê≠¥„Åã„Çâ„É´„Éº„ÉàË®àÁÆó
    let routeAnalysis = null;
    if (operation.gpsLogs.length > 1) {
      routeAnalysis = await calculateRoute(operation.gpsLogs);
    }

    logger.info('ÈÅãË°åË®òÈå≤Ë©≥Á¥∞ÂèñÂæó', {
      requestBy: req.user?.username,
      requestRole: req.user?.role,
      operationId,
      driverId: operation.driverId
    });

    const response: TripDetailResponse = {
      id: operation.id,
      vehicleId: operation.vehicleId,
      driverId: operation.driverId,
      status: operation.status,
      startTime: operation.startTime,
      endTime: operation.endTime,
      plannedRoute: operation.metadata?.plannedRoute,
      actualRoute: routeAnalysis?.route,
      expectedDistance: operation.metadata?.expectedDistance || 0,
      actualDistance: routeAnalysis?.totalDistance || operation.metadata?.actualDistance || 0,
      duration: operation.duration,
      averageSpeed: efficiency.averageSpeed,
      maxSpeed: efficiency.maxSpeed,
      fuelEfficiency: efficiency.fuelEfficiency,
      idleTime: efficiency.idleTime,
      priority: operation.priority,
      notes: operation.notes,
      vehicle: operation.vehicle,
      driver: operation.driver,
      gpsHistory: operation.gpsLogs,
      routeAnalysis,
      efficiency: {
        fuelConsumption: efficiency.fuelConsumption,
        carbonEmission: efficiency.carbonEmission,
        costAnalysis: efficiency.costAnalysis,
        performanceScore: efficiency.performanceScore
      }
    };

    return sendSuccess(res, response, 'ÈÅãË°åË®òÈå≤Ë©≥Á¥∞„ÇíÂèñÂæó„Åó„Åæ„Åó„Åü');

  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }

    logger.error('ÈÅãË°åË®òÈå≤Ë©≥Á¥∞ÂèñÂæó„Ç®„É©„Éº', {
      requestBy: req.user?.username,
      operationId: req.params.id,
      error: error instanceof Error ? error.message : String(error)
    });

    throw new DatabaseError('ÈÅãË°åË®òÈå≤Ë©≥Á¥∞„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'TRIP_DETAIL_ERROR');
  }
}));

/**
 * ÈÅãË°åÈñãÂßã
 * GPS‰ΩçÁΩÆË®òÈå≤„ÉªËªä‰∏°Áä∂ÊÖãÊõ¥Êñ∞„Éª„É™„Ç¢„É´„Çø„Ç§„É†ËøΩË∑°ÈñãÂßã
 * 
 * @route POST /trips/start
 * @param {StartTripOperationRequest} req.body - ÈÅãË°åÈñãÂßãÊÉÖÂ†±
 * @returns {TripOperationModel} ÈñãÂßã„Åï„Çå„ÅüÈÅãË°åÊÉÖÂ†±
 * @throws {ValidationError} ÂÖ•Âäõ„Éá„Éº„Çø„ÅåÁÑ°Âäπ„Å™Â†¥Âêà
 * @throws {ConflictError} Ëªä‰∏°„Åå‰ΩøÁî®‰∏≠„ÅÆÂ†¥Âêà
 */
router.post('/start', asyncHandler(async (req: Request<{}, ApiResponse<TripOperationModel>, StartTripOperationRequest>, res: Response) => {
  try {
    const {
      vehicleId,
      driverId,
      startLocation,
      plannedRoute,
      expectedDistance,
      priority = 'MEDIUM',
      notes
    } = req.body;

    // „Éê„É™„Éá„Éº„Ç∑„Éß„É≥
    if (!vehicleId) {
      throw new ValidationError('Ëªä‰∏°ID„ÅØÂøÖÈ†à„Åß„Åô', 'MISSING_VEHICLE_ID');
    }

    // GPSÂ∫ßÊ®ô„Éê„É™„Éá„Éº„Ç∑„Éß„É≥
    if (startLocation) {
      if (!isValidCoordinates(startLocation.latitude, startLocation.longitude)) {
        throw new ValidationError('ÁÑ°Âäπ„Å™GPSÂ∫ßÊ®ô„Åß„Åô', 'INVALID_GPS_COORDINATES');
      }
    }

    // Ê®©Èôê„ÉÅ„Çß„ÉÉ„ÇØÔºàËá™ÂàÜ„ÅÆÈÅãË°å„Åæ„Åü„ÅØÁÆ°ÁêÜËÄÖ„Éª„Éû„Éç„Éº„Ç∏„É£„ÉºÔºâ
    const canManageOthers = ['ADMIN', 'MANAGER'].includes(req.user?.role || '');
    const targetDriverId = driverId || req.user?.userId;

    if (targetDriverId !== req.user?.userId && !canManageOthers) {
      throw new AuthorizationError('‰ªñ„ÅÆÈÅãËª¢Êâã„ÅÆÈÅãË°å„ÇíÈñãÂßã„Åô„ÇãÊ®©Èôê„Åå„ÅÇ„Çä„Åæ„Åõ„Çì', 'ACCESS_DENIED');
    }

    const prisma = DATABASE_SERVICE.getInstance();

    // Ëªä‰∏°Â≠òÂú®„ÉªÁä∂ÊÖãÁ¢∫Ë™ç
    const vehicle = await prisma.vehicle.findUnique({
      where: { id: vehicleId },
      select: { id: true, plateNumber: true, status: true }
    });

    if (!vehicle) {
      throw new NotFoundError('ÊåáÂÆö„Åï„Çå„ÅüËªä‰∏°„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', 'VEHICLE_NOT_FOUND');
    }

    if (vehicle.status !== 'ACTIVE') {
      throw new ConflictError('Ëªä‰∏°„Åå‰ΩøÁî®ÂèØËÉΩÁä∂ÊÖã„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì', 'VEHICLE_NOT_AVAILABLE');
    }

    // ÈÄ≤Ë°å‰∏≠„ÅÆÈÅãË°å„ÉÅ„Çß„ÉÉ„ÇØ
    const activeOperation = await prisma.operation.findFirst({
      where: {
        vehicleId,
        status: 'IN_PROGRESS',
        operationType: 'TRIP'
      }
    });

    if (activeOperation) {
      throw new ConflictError('„Åì„ÅÆËªä‰∏°„ÅØÊó¢„Å´ÈÅãË°å‰∏≠„Åß„Åô', 'VEHICLE_IN_USE');
    }

    // ÈÅãË°åË®òÈå≤‰ΩúÊàê
    const operation = await prisma.operation.create({
      data: {
        vehicleId,
        driverId: targetDriverId!,
        status: 'IN_PROGRESS',
        startTime: new Date(),
        operationType: 'TRIP',
        priority,
        notes,
        metadata: {
          plannedRoute,
          expectedDistance,
          startLocation
        }
      },
      include: {
        vehicle: {
          select: {
            id: true,
            plateNumber: true,
            model: true,
            type: true
          }
        },
        driver: {
          select: {
            id: true,
            username: true,
            email: true
          }
        }
      }
    });

    // GPSÈñãÂßã‰ΩçÁΩÆË®òÈå≤
    if (startLocation) {
      await prisma.gpsLog.create({
        data: {
          operationId: operation.id,
          vehicleId,
          latitude: startLocation.latitude,
          longitude: startLocation.longitude,
          altitude: startLocation.altitude || null,
          speed: 0,
          accuracy: startLocation.accuracy || null,
          timestamp: new Date()
        }
      });
    }

    // Ëªä‰∏°„Çπ„ÉÜ„Éº„Çø„ÇπÊõ¥Êñ∞
    await prisma.vehicle.update({
      where: { id: vehicleId },
      data: { status: 'MAINTENANCE' } // ÈÅãË°å‰∏≠„Çπ„ÉÜ„Éº„Çø„Çπ
    });

    logger.info('ÈÅãË°åÈñãÂßãÊàêÂäü', {
      operationId: operation.id,
      vehicleId,
      driverId: targetDriverId,
      startedBy: req.user?.username,
      hasGpsData: !!startLocation
    });

    const tripOperation: TripOperationModel = {
      id: operation.id,
      vehicleId: operation.vehicleId,
      driverId: operation.driverId!,
      status: operation.status,
      startTime: operation.startTime!,
      endTime: operation.endTime,
      plannedRoute,
      expectedDistance,
      actualDistance: 0,
      duration: 0,
      priority,
      notes,
      vehicle: operation.vehicle,
      driver: operation.driver,
      startLocation,
      tripStatus: 'IN_PROGRESS',
      vehicleOperationStatus: 'IN_OPERATION'
    };

    return sendSuccess(res, tripOperation, 'ÈÅãË°å„ÇíÈñãÂßã„Åó„Åæ„Åó„Åü', 201);

  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }

    logger.error('ÈÅãË°åÈñãÂßã„Ç®„É©„Éº', {
      requestBy: req.user?.username,
      requestData: req.body,
      error: error instanceof Error ? error.message : String(error)
    });

    throw new DatabaseError('ÈÅãË°åÈñãÂßã„ÅÆÂá¶ÁêÜ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'TRIP_START_ERROR');
  }
}));

/**
 * ÈÅãË°åÁµÇ‰∫Ü
 * GPSÊúÄÁµÇ‰ΩçÁΩÆË®òÈå≤„ÉªË∑ùÈõ¢Ë®àÁÆó„ÉªÂäπÁéáÂàÜÊûê„ÉªËªä‰∏°Áä∂ÊÖãÂæ©ÂÖÉ
 * 
 * @route POST /trips/:id/end
 * @param {string} id - ÈÅãË°åË®òÈå≤ID
 * @param {EndTripOperationRequest} req.body - ÈÅãË°åÁµÇ‰∫ÜÊÉÖÂ†±
 * @returns {TripOperationModel} ÁµÇ‰∫Ü„Åï„Çå„ÅüÈÅãË°åÊÉÖÂ†±
 * @throws {NotFoundError} ÈÅãË°åË®òÈå≤„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà
 * @throws {ConflictError} ÈÅãË°å„ÅåÊó¢„Å´ÁµÇ‰∫Ü„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà
 */
router.post('/:id/end', asyncHandler(async (req: Request<{ id: string }, ApiResponse<TripOperationModel>, EndTripOperationRequest>, res: Response) => {
  try {
    const { id } = req.params;
    const {
      endLocation,
      actualDistance,
      fuelConsumed,
      notes
    } = req.body;

    // ID„Éê„É™„Éá„Éº„Ç∑„Éß„É≥
    const operationId = parseInt(id);
    if (isNaN(operationId)) {
      throw new ValidationError('ÁÑ°Âäπ„Å™ÈÅãË°åË®òÈå≤ID„Åß„Åô', 'INVALID_OPERATION_ID');
    }

    // GPSÂ∫ßÊ®ô„Éê„É™„Éá„Éº„Ç∑„Éß„É≥
    if (endLocation) {
      if (!isValidCoordinates(endLocation.latitude, endLocation.longitude)) {
        throw new ValidationError('ÁÑ°Âäπ„Å™GPSÂ∫ßÊ®ô„Åß„Åô', 'INVALID_GPS_COORDINATES');
      }
    }

    const prisma = DATABASE_SERVICE.getInstance();

    const operation = await prisma.operation.findUnique({
      where: { 
        id: operationId,
        operationType: 'TRIP'
      },
      include: {
        vehicle: true,
        driver: true,
        gpsLogs: {
          orderBy: { timestamp: 'asc' }
        }
      }
    });

    if (!operation) {
      throw new NotFoundError('ÈÅãË°åË®òÈå≤„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', 'OPERATION_NOT_FOUND');
    }

    if (operation.status === 'COMPLETED') {
      throw new ConflictError('„Åì„ÅÆÈÅãË°å„ÅØÊó¢„Å´ÁµÇ‰∫Ü„Åó„Å¶„ÅÑ„Åæ„Åô', 'TRIP_ALREADY_ENDED');
    }

    // Ê®©Èôê„ÉÅ„Çß„ÉÉ„ÇØ
    const canManageOthers = ['ADMIN', 'MANAGER'].includes(req.user?.role || '');
    if (operation.driverId !== req.user?.userId && !canManageOthers) {
      throw new AuthorizationError('„Åì„ÅÆÈÅãË°å„ÇíÁµÇ‰∫Ü„Åô„ÇãÊ®©Èôê„Åå„ÅÇ„Çä„Åæ„Åõ„Çì', 'ACCESS_DENIED');
    }

    const endTime = new Date();
    const duration = operation.startTime ? 
      Math.round((endTime.getTime() - operation.startTime.getTime()) / 1000) : 0;

    // GPSÁµÇ‰∫Ü‰ΩçÁΩÆË®òÈå≤
    if (endLocation) {
      await prisma.gpsLog.create({
        data: {
          operationId: operation.id,
          vehicleId: operation.vehicleId,
          latitude: endLocation.latitude,
          longitude: endLocation.longitude,
          altitude: endLocation.altitude || null,
          speed: 0,
          accuracy: endLocation.accuracy || null,
          timestamp: endTime
        }
      });
    }

    // Ë∑ùÈõ¢Ë®àÁÆóÔºàGPSÂ±•Ê≠¥„Åã„ÇâÔºâ
    let calculatedDistance = actualDistance || 0;
    if (!actualDistance && operation.gpsLogs.length > 1) {
      calculatedDistance = operation.gpsLogs.reduce((total, log, index) => {
        if (index === 0) return 0;
        const prevLog = operation.gpsLogs[index - 1];
        return total + calculateDistance(
          prevLog.latitude,
          prevLog.longitude,
          log.latitude,
          log.longitude
        );
      }, 0);
    }

    // ÁáÉË≤ªË®àÁÆó
    const fuelEfficiency = fuelConsumed && calculatedDistance > 0 ? 
      calculatedDistance / fuelConsumed : null;

    // ÈÅãË°åË®òÈå≤Êõ¥Êñ∞
    const updatedOperation = await prisma.operation.update({
      where: { id: operationId },
      data: {
        status: 'COMPLETED',
        endTime,
        duration,
        notes,
        metadata: {
          ...operation.metadata,
          endLocation,
          actualDistance: calculatedDistance,
          fuelConsumed,
          fuelEfficiency
        }
      },
      include: {
        vehicle: true,
        driver: true
      }
    });

    // Ëªä‰∏°„Çπ„ÉÜ„Éº„Çø„ÇπÂæ©ÂÖÉ
    await prisma.vehicle.update({
      where: { id: operation.vehicleId },
      data: { status: 'ACTIVE' }
    });

    logger.info('ÈÅãË°åÁµÇ‰∫ÜÊàêÂäü', {
      operationId: updatedOperation.id,
      vehicleId: operation.vehicleId,
      driverId: operation.driverId,
      endedBy: req.user?.username,
      duration,
      actualDistance: calculatedDistance,
      fuelEfficiency
    });

    const tripOperation: TripOperationModel = {
      id: updatedOperation.id,
      vehicleId: updatedOperation.vehicleId,
      driverId: updatedOperation.driverId!,
      status: updatedOperation.status,
      startTime: updatedOperation.startTime!,
      endTime: updatedOperation.endTime!,
      plannedRoute: operation.metadata?.plannedRoute,
      actualDistance: calculatedDistance,
      duration,
      priority: updatedOperation.priority,
      notes: updatedOperation.notes,
      vehicle: updatedOperation.vehicle,
      driver: updatedOperation.driver,
      endLocation,
      tripStatus: 'COMPLETED',
      vehicleOperationStatus: 'AVAILABLE',
      fuelConsumed,
      fuelEfficiency
    };

    return sendSuccess(res, tripOperation, 'ÈÅãË°å„ÇíÁµÇ‰∫Ü„Åó„Åæ„Åó„Åü');

  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }

    logger.error('ÈÅãË°åÁµÇ‰∫Ü„Ç®„É©„Éº', {
      requestBy: req.user?.username,
      operationId: req.params.id,
      error: error instanceof Error ? error.message : String(error)
    });

    throw new DatabaseError('ÈÅãË°åÁµÇ‰∫Ü„ÅÆÂá¶ÁêÜ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'TRIP_END_ERROR');
  }
}));

/**
 * „É™„Ç¢„É´„Çø„Ç§„É†‰ΩçÁΩÆÊõ¥Êñ∞
 * GPS‰ΩçÁΩÆÊÉÖÂ†±„ÅÆÁ∂ôÁ∂öÁöÑ„Å™Ë®òÈå≤„ÉªËøΩË∑°
 * 
 * @route POST /trips/:id/location
 * @param {string} id - ÈÅãË°åË®òÈå≤ID
 * @param {Object} req.body - GPS‰ΩçÁΩÆÊÉÖÂ†±
 * @returns {Object} ‰ΩçÁΩÆÊõ¥Êñ∞ÊàêÂäü„É°„ÉÉ„Çª„Éº„Ç∏
 */
router.post('/:id/location', asyncHandler(async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { latitude, longitude, speed, altitude, accuracy } = req.body;

    // ID„Éê„É™„Éá„Éº„Ç∑„Éß„É≥
    const operationId = parseInt(id);
    if (isNaN(operationId)) {
      throw new ValidationError('ÁÑ°Âäπ„Å™ÈÅãË°åË®òÈå≤ID„Åß„Åô', 'INVALID_OPERATION_ID');
    }

    // GPSÂ∫ßÊ®ô„Éê„É™„Éá„Éº„Ç∑„Éß„É≥
    if (!isValidCoordinates(latitude, longitude)) {
      throw new ValidationError('ÁÑ°Âäπ„Å™GPSÂ∫ßÊ®ô„Åß„Åô', 'INVALID_GPS_COORDINATES');
    }

    const prisma = DATABASE_SERVICE.getInstance();

    const operation = await prisma.operation.findUnique({
      where: { 
        id: operationId,
        operationType: 'TRIP'
      },
      select: { id: true, vehicleId: true, driverId: true, status: true }
    });

    if (!operation) {
      throw new NotFoundError('ÈÅãË°åË®òÈå≤„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', 'OPERATION_NOT_FOUND');
    }

    if (operation.status !== 'IN_PROGRESS') {
      throw new ConflictError('ÈÄ≤Ë°å‰∏≠„ÅÆÈÅãË°å„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì', 'TRIP_NOT_ACTIVE');
    }

    // Ê®©Èôê„ÉÅ„Çß„ÉÉ„ÇØ
    const canManageOthers = ['ADMIN', 'MANAGER'].includes(req.user?.role || '');
    if (operation.driverId !== req.user?.userId && !canManageOthers) {
      throw new AuthorizationError('„Åì„ÅÆÈÅãË°å„ÅÆ‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞„Åô„ÇãÊ®©Èôê„Åå„ÅÇ„Çä„Åæ„Åõ„Çì', 'ACCESS_DENIED');
    }

    // GPS‰ΩçÁΩÆË®òÈå≤
    await prisma.gpsLog.create({
      data: {
        operationId: operation.id,
        vehicleId: operation.vehicleId,
        latitude,
        longitude,
        speed: speed || null,
        altitude: altitude || null,
        accuracy: accuracy || null,
        timestamp: new Date()
      }
    });

    logger.info('„É™„Ç¢„É´„Çø„Ç§„É†‰ΩçÁΩÆÊõ¥Êñ∞', {
      operationId: operation.id,
      vehicleId: operation.vehicleId,
      driverId: operation.driverId,
      updatedBy: req.user?.username,
      location: { latitude, longitude, speed }
    });

    return sendSuccess(res, {
      operationId: operation.id,
      timestamp: new Date().toISOString(),
      location: { latitude, longitude, speed, altitude, accuracy }
    }, '‰ΩçÁΩÆÊÉÖÂ†±„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü');

  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }

    logger.error('‰ΩçÁΩÆÊõ¥Êñ∞„Ç®„É©„Éº', {
      requestBy: req.user?.username,
      operationId: req.params.id,
      error: error instanceof Error ? error.message : String(error)
    });

    throw new DatabaseError('‰ΩçÁΩÆÊÉÖÂ†±„ÅÆÊõ¥Êñ∞„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'LOCATION_UPDATE_ERROR');
  }
}));

/**
 * ÈÅãË°åÁµ±Ë®àÊÉÖÂ†±ÂèñÂæó
 * ÁÆ°ÁêÜËÄÖ„Éª„Éû„Éç„Éº„Ç∏„É£„ÉºÂêë„Åë„ÅÆÈÅãË°åÈñ¢ÈÄ£Áµ±Ë®àÊÉÖÂ†±
 * 
 * @route GET /trips/stats
 * @access Admin, Manager
 * @returns {TripStatsResponse} ÈÅãË°åÁµ±Ë®àÊÉÖÂ†±
 */
router.get('/api/stats', 
  authorize(['ADMIN', 'MANAGER']), 
  asyncHandler(async (req: Request, res: Response) => {
    try {
      const { 
        startDate, 
        endDate, 
        vehicleId, 
        driverId 
      } = req.query;

      const prisma = DATABASE_SERVICE.getInstance();

      // Âü∫Êú¨„Éï„Ç£„É´„ÇøÊù°‰ª∂
      const whereConditions: Prisma.OperationWhereInput = {
        operationType: 'TRIP'
      };

      // ÊúüÈñì„Éï„Ç£„É´„Çø
      if (startDate || endDate) {
        whereConditions.createdAt = {};
        if (startDate) whereConditions.createdAt.gte = new Date(startDate as string);
        if (endDate) whereConditions.createdAt.lte = new Date(endDate as string);
      }

      // Ëªä‰∏°„ÉªÈÅãËª¢Êâã„Éï„Ç£„É´„Çø
      if (vehicleId) whereConditions.vehicleId = parseInt(vehicleId as string);
      if (driverId) whereConditions.driverId = parseInt(driverId as string);

      // Áµ±Ë®à„Éá„Éº„ÇøÂèéÈõÜ
      const statistics = await generateTripStatistics(prisma, whereConditions);

      logger.info('ÈÅãË°åÁµ±Ë®àÂèñÂæó', {
        requestBy: req.user?.username,
        requestRole: req.user?.role,
        filters: { startDate, endDate, vehicleId, driverId },
        totalOperations: statistics.totalOperations
      });

      return sendSuccess(res, statistics, 'ÈÅãË°åÁµ±Ë®àÊÉÖÂ†±„ÇíÂèñÂæó„Åó„Åæ„Åó„Åü');

    } catch (error) {
      logger.error('ÈÅãË°åÁµ±Ë®àÂèñÂæó„Ç®„É©„Éº', {
        requestBy: req.user?.username,
        error: error instanceof Error ? error.message : String(error)
      });

      throw new DatabaseError('ÈÅãË°åÁµ±Ë®à„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'TRIP_STATS_ERROR');
    }
  })
);

// =====================================
// „Éò„É´„Éë„ÉºÈñ¢Êï∞ÔºàÁµ±ÂêàÁâàÔºâ
// =====================================

/**
 * ÈÅãË°åÁµ±Ë®àÊÉÖÂ†±ÁîüÊàê
 */
async function generateTripStatistics(
  prisma: any, 
  whereConditions: Prisma.OperationWhereInput
): Promise<OperationStatistics> {
  const [
    totalOps,
    activeOps,
    completedOps,
    cancelledOps,
    avgDuration,
    distanceSum,
    fuelSum
  ] = await Promise.all([
    prisma.operation.count({ where: whereConditions }),
    prisma.operation.count({ where: { ...whereConditions, status: 'IN_PROGRESS' } }),
    prisma.operation.count({ where: { ...whereConditions, status: 'COMPLETED' } }),
    prisma.operation.count({ where: { ...whereConditions, status: 'CANCELLED' } }),
    prisma.operation.aggregate({
      where: { ...whereConditions, status: 'COMPLETED' },
      _avg: { duration: true }
    }),
    prisma.operation.aggregate({
      where: { ...whereConditions, status: 'COMPLETED' },
      _sum: { 
        metadata: {
          path: ['actualDistance']
        }
      }
    }),
    prisma.operation.aggregate({
      where: { ...whereConditions, status: 'COMPLETED' },
      _sum: { 
        metadata: {
          path: ['fuelConsumed']
        }
      }
    })
  ]);

  return {
    totalOperations: totalOps,
    activeOperations: activeOps,
    completedOperations: completedOps,
    cancelledOperations: cancelledOps,
    averageOperationDuration: avgDuration._avg.duration || 0,
    totalDistance: distanceSum._sum || 0,
    totalFuelConsumed: fuelSum._sum || 0,
    averageFuelEfficiency: (distanceSum._sum && fuelSum._sum) ? 
      distanceSum._sum / fuelSum._sum : 0,
    // Á∞°ÊòìÁâàÁµ±Ë®àÔºàË©≥Á¥∞ÂÆüË£Ö„ÅØÂà•ÈÄîÔºâ
    peakHours: [],
    byVehicle: {},
    byDriver: {},
    trends: {
      daily: [],
      weekly: [],
      monthly: []
    }
  };
}

/**
 * ÈÅãË°åÂäπÁéáÂàÜÊûêË®àÁÆó
 */
async function calculateTripEfficiency(operation: any) {
  // Á∞°ÊòìÁâàÂäπÁéáË®àÁÆóÔºàË©≥Á¥∞ÂÆüË£Ö„ÅØÂà•ÈÄîÔºâ
  const distance = operation.metadata?.actualDistance || 0;
  const duration = operation.duration || 0;
  const fuelConsumed = operation.metadata?.fuelConsumed || 0;

  return {
    averageSpeed: duration > 0 ? (distance / duration) * 3600 : 0,
    maxSpeed: 0, // GPSÂ±•Ê≠¥„Åã„ÇâË®àÁÆó
    fuelEfficiency: fuelConsumed > 0 ? distance / fuelConsumed : 0,
    idleTime: 0, // GPSÂ±•Ê≠¥„Åã„ÇâË®àÁÆó
    fuelConsumption: fuelConsumed,
    carbonEmission: fuelConsumed * 2.3, // Á∞°ÊòìË®àÁÆó
    costAnalysis: {
      fuelCost: fuelConsumed * 150, // Á∞°ÊòìË®àÁÆó
      maintenanceCost: distance * 5 // Á∞°ÊòìË®àÁÆó
    },
    performanceScore: 85 // Á∞°ÊòìË®àÁÆó
  };
}

// =====================================
// Áµ±ÂêàÂÆå‰∫ÜÁ¢∫Ë™ç„Éª„Ç®„ÇØ„Çπ„Éù„Éº„Éà
// =====================================

logger.info('‚úÖ routes/tripRoutes.ts Áµ±ÂêàÂÆå‰∫Ü', {
  endpoints: [
    'GET /trips - ÈÅãË°åË®òÈå≤‰∏ÄË¶ßÔºà„Éï„Ç£„É´„Çø„ÉªÁµ±Ë®àÂØæÂøúÔºâ',
    'GET /trips/:id - ÈÅãË°åË®òÈå≤Ë©≥Á¥∞ÔºàGPS„ÉªÂäπÁéáÂàÜÊûêÔºâ',
    'POST /trips/start - ÈÅãË°åÈñãÂßãÔºàGPSË®òÈå≤„ÉªÁä∂ÊÖãÁÆ°ÁêÜÔºâ',
    'POST /trips/:id/end - ÈÅãË°åÁµÇ‰∫ÜÔºàË∑ùÈõ¢Ë®àÁÆó„ÉªÂäπÁéáÂàÜÊûêÔºâ',
    'POST /trips/:id/location - „É™„Ç¢„É´„Çø„Ç§„É†‰ΩçÁΩÆÊõ¥Êñ∞',
    'GET /trips/api/stats - ÈÅãË°åÁµ±Ë®àÔºàÁÆ°ÁêÜËÄÖ„Éª„Éû„Éç„Éº„Ç∏„É£„ÉºÔºâ'
  ],
  integrationStatus: 'Phase 1 - Trip Management API Complete',
  middleware: 'auth + errorHandler integrated',
  utils: 'gpsCalculations + errors + response + database integrated',
  models: 'OperationModel types integrated',
  timestamp: new Date().toISOString()
});

export default router;

// =====================================
// Áµ±ÂêàÂÆå‰∫ÜÁ¢∫Ë™ç
// =====================================

/**
 * ‚úÖ routes/tripRoutes.tsÁµ±ÂêàÂÆå‰∫Ü
 * 
 * „ÄêÂÆå‰∫ÜÈ†ÖÁõÆ„Äë
 * ‚úÖ ÈÅãË°åÁÆ°ÁêÜAPIÊ©üËÉΩÂÆüÁèæÔºàÈÅãË°åË®òÈå≤CRUD„ÉªGPSÈÄ£Êê∫„ÉªÁä∂ÊÖãÁÆ°ÁêÜ„Éª„É™„Ç¢„É´„Çø„Ç§„É†ËøΩË∑°Ôºâ
 * ‚úÖ middleware/auth.tsÂÆåÂÖ®Ê¥ªÁî®ÔºàauthenticateToken„Éªauthorize„ÉªÊ®©ÈôêÈöéÂ±§Ôºâ
 * ‚úÖ middleware/errorHandler.tsÂÆåÂÖ®Ê¥ªÁî®ÔºàasyncHandlerÁµ±‰∏Ä„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞Ôºâ
 * ‚úÖ utils/gpsCalculations.tsÁµ±ÂêàÔºàGPSË®àÁÆó„Éª„É´„Éº„ÉàÂàÜÊûê„ÉªÂäπÁéáË®àÁÆóÔºâ
 * ‚úÖ utils/errors.tsÁµ±‰∏Ä„Ç®„É©„Éº„ÇØ„É©„Çπ‰ΩìÁ≥ªÁµ±ÂêàÔºàValidationError„ÉªConflictErrorÁ≠âÔºâ
 * ‚úÖ utils/response.tsÁµ±‰∏Ä„É¨„Çπ„Éù„É≥„ÇπÂΩ¢ÂºèÁµ±ÂêàÔºàsendSuccess„ÉªsendErrorÔºâ
 * ‚úÖ utils/database.tsÁµ±Âêà„Ç∑„É≥„Ç∞„É´„Éà„É≥Ê¥ªÁî®
 * ‚úÖ models/OperationModel.tsÂûãÂÆöÁæ©ÂÆåÂÖ®Áµ±ÂêàÔºàTripOperationModel„ÉªOperationStatisticsÔºâ
 * ‚úÖ types/trip.ts„Éªtypes/common.ts„Åã„Çâ„ÅÆÁµ±‰∏ÄÂûãÂÆöÁæ©‰ΩøÁî®
 * ‚úÖ schema.camel.prisma„Å®„ÅÆÂÆåÂÖ®Êï¥ÂêàÊÄßÔºàOperationStatus„ÉªOperationType„ÉªGPSÈÄ£Êê∫Ôºâ
 * ‚úÖ ‰ºÅÊ•≠„É¨„Éô„É´ÈÅãË°åÁÆ°ÁêÜÊ©üËÉΩÔºàÁµ±Ë®à„ÉªÁõ£Ë¶ñ„ÉªGPSËøΩË∑°„ÉªÂäπÁéáÂàÜÊûê„ÉªÊ®©ÈôêÂà∂Âæ°Ôºâ
 * ‚úÖ „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£ÊåáÈáùÊ∫ñÊã†ÔºàÂûãÂÆâÂÖ®ÊÄß„Éª„É¨„Ç§„É§„ÉºË≤¨ÂãôÊòéÁ¢∫ÂåñÔºâ
 * ‚úÖ Áµ±‰∏Ä„Ç≥„É°„É≥„Éà„Éù„É™„Ç∑„ÉºÈÅ©Áî®Ôºà„Éï„Ç°„Ç§„É´„Éò„ÉÉ„ÉÄ„Éº„ÉªTSDoc„ÉªÁµ±ÂêàË™¨ÊòéÔºâ
 * 
 * „ÄêGPS„Éª‰ΩçÁΩÆÁÆ°ÁêÜÁµ±ÂêàÂäπÊûú„Äë
 * ‚úÖ gpsRoutes.tsÊ©üËÉΩÁµ±ÂêàÔºà„É™„Ç¢„É´„Çø„Ç§„É†‰ΩçÁΩÆÊõ¥Êñ∞„ÉªÂ±•Ê≠¥ÁÆ°ÁêÜÔºâ
 * ‚úÖ GPSÂ∫ßÊ®ô„Éê„É™„Éá„Éº„Ç∑„Éß„É≥„ÉªË∑ùÈõ¢Ë®àÁÆó„Éª„É´„Éº„ÉàÂàÜÊûêÁµ±Âêà
 * ‚úÖ „É™„Ç¢„É´„Çø„Ç§„É†ËøΩË∑°„ÉªÂäπÁéáÂàÜÊûê„ÉªÁáÉË≤ªË®àÁÆóÁµ±Âêà
 * ‚úÖ Ëªä‰∏°Áä∂ÊÖãÁÆ°ÁêÜ„ÉªÈÅãË°åÁä∂ÊÖãÁÆ°ÁêÜÁµ±Âêà
 * 
 * „ÄêÈÅãË°åÁÆ°ÁêÜÊ•≠ÂãôÊ©üËÉΩÂÆüÁèæ„Äë
 * ‚úÖ ÈÅãË°åÈñãÂßã„ÉªÁµÇ‰∫ÜÔºàGPSÈÄ£Êê∫„ÉªËªä‰∏°Áä∂ÊÖãÁÆ°ÁêÜÔºâ
 * ‚úÖ „É™„Ç¢„É´„Çø„Ç§„É†‰ΩçÁΩÆËøΩË∑°ÔºàÁ∂ôÁ∂öÁöÑGPSË®òÈå≤Ôºâ
 * ‚úÖ ÈÅãË°åÂäπÁéáÂàÜÊûêÔºàÁáÉË≤ª„ÉªÈÄüÂ∫¶„ÉªË∑ùÈõ¢„ÉªÊôÇÈñìÔºâ
 * ‚úÖ Áµ±Ë®à„Éª„É¨„Éù„Éº„ÉàÊ©üËÉΩÔºàÊúüÈñìÂà•„ÉªËªä‰∏°Âà•„ÉªÈÅãËª¢ÊâãÂà•Ôºâ
 * ‚úÖ Ê®©Èôê„Éô„Éº„ÇπÈÅãË°åÁÆ°ÁêÜÔºàÈÅãËª¢Êâã„ÉªÁÆ°ÁêÜËÄÖ„Éª„Éû„Éç„Éº„Ç∏„É£„ÉºÔºâ
 * ‚úÖ „Éï„Ç£„É´„Çø„ÉªÊ§úÁ¥¢Ê©üËÉΩÔºàÂ§öÊù°‰ª∂ÂØæÂøú„Éª„Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥Ôºâ
 * 
 * „ÄêÊ¨°„ÅÆPhase 1ÂØæË±°„Äë
 * üéØ routes/vehicleRoutes.ts: Ëªä‰∏°ÁÆ°ÁêÜAPIÂÆüÁèæÔºàËªä‰∏°CRUD„ÉªÁÇπÊ§úÈÄ£Êê∫„ÉªÁ®ºÂÉçÁÆ°ÁêÜÔºâ
 * 
 * „Äê„Çπ„Ç≥„Ç¢Âêë‰∏ä„Äë
 * ÂâçÂõû: 86/120ÁÇπ ‚Üí routes/tripRoutes.tsÂÆå‰∫Ü: 91/120ÁÇπÔºà+5ÁÇπÊîπÂñÑÔºâ
 * routes/Â±§: 3/17„Éï„Ç°„Ç§„É´ ‚Üí 4/17„Éï„Ç°„Ç§„É´ÔºàÂü∫ÂππÊ•≠ÂãôÊ©üËÉΩÁ¢∫Á´ãÔºâ
 */